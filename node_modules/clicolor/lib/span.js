"use strict";
const pen_1 = require("./pen");
const status_1 = require("./status");
class Span {
    constructor(pen, spans) {
        this.pen = pen;
        this.spans = spans;
        while (spans.length == 1) {
            const onlySpan = spans[0];
            if (onlySpan instanceof Span) {
                pen = pen.merge(onlySpan.pen);
                spans = onlySpan.spans;
            }
            else {
                break;
            }
        }
        this.length = this.spans.length == 0 ? 0 : this.spans.map(s => s.length).reduce((a, b) => a + b);
    }
    slice(start = 0, end = this.length) {
        if (end < 0)
            end += this.length;
        if (start < 0)
            start += this.length;
        if (end < start)
            throw new Error("No shenanigans");
        const rv = [];
        let i = 0;
        this.spans.forEach(span => {
            if (i < end && i + span.length >= start) {
                if (i >= start && i + span.length < end) {
                    rv.push(span);
                }
                else {
                    rv.push(span.slice(Math.max(start - i, 0), Math.min(end - i, span.length)));
                }
            }
            i += span.length;
        });
        return new Span(this.pen, rv);
    }
    render(buffer, active, currentPen, emitCodes) {
        const pen = currentPen.merge(this.pen);
        this.spans.forEach(span => {
            if (span instanceof Span) {
                active = span.render(buffer, active, pen, emitCodes);
            }
            else if (span.length > 0) {
                if (emitCodes)
                    buffer.push(pen.render(active));
                active = pen;
                buffer.push(span);
            }
        });
        return active;
    }
    toString(emitCodes = true) {
        const buffer = [];
        const active = this.render(buffer, pen_1.EMPTY_PEN, pen_1.EMPTY_PEN, emitCodes);
        if (emitCodes)
            buffer.push(pen_1.EMPTY_PEN.render(active));
        return buffer.join("");
    }
}
exports.Span = Span;
function span(pen, ...spans) {
    const rv = new Span(pen, spans);
    if (pen.padding != null) {
        if (pen.padding < 0 && -pen.padding > rv.length) {
            return new Span(pen, [status_1.spaces(-pen.padding - rv.length)].concat(spans));
        }
        else if (pen.padding > 0 && pen.padding > rv.length) {
            return new Span(pen, spans.concat([status_1.spaces(pen.padding - rv.length)]));
        }
    }
    return rv;
}
exports.span = span;
//# sourceMappingURL=span.js.map