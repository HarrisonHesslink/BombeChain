"use strict";
const pen_1 = require("./pen");
const span_1 = require("./span");
const status_1 = require("./status");
const TAG = /<([^>]+)>/g;
const DEFAULT_STYLES = {
    dim: "888",
    timestamp: "0cc",
    warning: "f60",
    error: "c00"
};
class CliColor {
    constructor(options = {}) {
        this._useColor = false;
        this._onTTY = false;
        if (Object.keys(process.stdout.constructor.prototype).indexOf("isTTY") >= 0) {
            this._useColor = true;
            this._onTTY = true;
        }
        this._quiet = false;
        this._updater = new status_1.StatusUpdater({
            width: options.width || this.screenWidth(),
            frequency: options.frequency
        });
        if (options.useColor != null)
            this.useColor(options.useColor);
        if (options.quiet != null)
            this.quiet(options.quiet);
        this.styles = new Map();
        for (const k in DEFAULT_STYLES)
            this.styles.set(k, DEFAULT_STYLES[k]);
        if (options.styles)
            for (const k in options.styles)
                this.styles.set(k, options.styles[k]);
    }
    useColor(x) {
        this._useColor = x;
    }
    quiet(x) {
        this._quiet = x;
    }
    isColor() {
        return this._useColor;
    }
    isQuiet() {
        return this._quiet;
    }
    displayTo(stream, ...message) {
        const clear = this._onTTY ? this._updater.clear() : "";
        const text = this.merge(...message).toString(this._useColor);
        stream.write(clear + text + "\n");
    }
    display(...message) {
        this.displayTo(process.stdout, ...message);
    }
    displayVerbose(...message) {
        if (!this._quiet)
            this.displayTo(process.stdout, ...message);
    }
    displayError(...message) {
        const color = this.styles.get("error") || DEFAULT_STYLES.error;
        this.displayTo(process.stderr, this.color(color, "ERROR"), ": ", ...message);
    }
    displayWarning(...message) {
        const color = this.styles.get("warning") || DEFAULT_STYLES.warning;
        this.displayTo(process.stderr, this.color(color, "WARNING"), ": ", ...message);
    }
    merge(...spans) {
        return span_1.span(pen_1.EMPTY_PEN, ...spans);
    }
    color(colorName, ...spans) {
        colorName = this.styles.get(colorName) || colorName;
        return span_1.span(pen_1.Pen.make({ color: colorName }), ...spans);
    }
    backgroundColor(colorName, ...spans) {
        colorName = this.styles.get(colorName) || colorName;
        return span_1.span(pen_1.Pen.make({ backgroundColor: colorName }), ...spans);
    }
    underline(...spans) {
        return span_1.span(pen_1.Pen.make({ underline: true }), ...spans);
    }
    screenWidth() {
        return (process && this._onTTY) ? process.stdout.columns : 80;
    }
    status(...message) {
        if (!this._onTTY || this._quiet)
            return;
        if (message.length == 0) {
            process.stdout.write(this._updater.clear());
            return;
        }
        process.stdout.write(this._updater.update(this.merge(...message).toString()));
    }
    padLeft(length, ...spans) {
        const s = this.merge(...spans);
        if (length > s.length) {
            return this.merge(status_1.spaces(length - s.length), ...spans);
        }
        return s;
    }
    padRight(length, ...spans) {
        const s = this.merge(...spans);
        if (length > span_1.span.length) {
            return this.merge(...spans, status_1.spaces(length - s.length));
        }
        return s;
    }
    format(descriptors, s) {
        const penmap = (descriptors instanceof Map) ? descriptors : pen_1.Pen.format(descriptors);
        const stack = [];
        let lastIndex = 0;
        const deadItem = { tag: "", index: 0, buffer: [] };
        stack.push(deadItem);
        let m = TAG.exec(s);
        while (m != null) {
            const tag = m[1], index = m.index;
            if (index == 0 || s[index - 1] != "\\") {
                stack[stack.length - 1].buffer.push(s.slice(lastIndex, index));
                if (tag[0] == "/") {
                    const start = stack.pop() || deadItem;
                    if (start.tag == "")
                        throw new Error(`Closed tag with no open tag (${tag} at ${index})`);
                    if (start.tag != tag.slice(1)) {
                        throw new Error(`Mismatched tags: ${start.tag} at ${start.index} vs ${tag} at ${index}`);
                    }
                    if (!penmap.has(start.tag))
                        throw new Error(`Unknown tag descriptor: ${start.tag} at ${start.index}`);
                    const pen = penmap.get(start.tag) || pen_1.EMPTY_PEN;
                    stack[stack.length - 1].buffer.push(span_1.span(pen, ...start.buffer));
                }
                else {
                    stack.push({ tag, index, buffer: [] });
                }
                lastIndex = index + m[0].length;
            }
            m = TAG.exec(s);
        }
        if (stack.length != 1)
            throw new Error(`Missing end tag for ${stack[stack.length - 1].tag}`);
        const start = stack.pop() || deadItem;
        start.buffer.push(s.slice(lastIndex));
        return span_1.span(pen_1.EMPTY_PEN, ...start.buffer);
    }
}
exports.CliColor = CliColor;
function clicolor(options = {}) {
    return new CliColor(options);
}
exports.clicolor = clicolor;
//# sourceMappingURL=clicolor.js.map